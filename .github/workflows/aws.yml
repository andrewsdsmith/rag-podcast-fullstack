name: Deploy to Environment

on:
  push:
    branches:
      - chore/aws-actions-deploy
    tags:
      - "v*-dev"
      - "v*-prod"

env:
  AWS_REGION: eu-west-2
  ECR_REPOSITORY_FRONTEND: rag-podcast-fullstack/frontend
  ECR_REPOSITORY_BACKEND: rag-podcast-fullstack/backend
  APP_DIR: /home/ec2-user/app # Explicit directory path

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        id: set-env
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          if [[ $TAG == *-prod ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_OUTPUT
            echo "EC2_INSTANCE_ID=${{ secrets.PROD_EC2_INSTANCE_ID }}" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=${TAG}" >> $GITHUB_OUTPUT
          else
            echo "ENVIRONMENT=development" >> $GITHUB_OUTPUT
            echo "EC2_INSTANCE_ID=${{ secrets.DEV_EC2_INSTANCE_ID }}" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=${TAG}" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:${{ steps.set-env.outputs.ENVIRONMENT }}-latest

      - name: Build and push Backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:${{ steps.set-env.outputs.ENVIRONMENT }}-latest

      - name: Prepare Docker Compose File
        run: |
          FRONTEND_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:${{ steps.set-env.outputs.ENVIRONMENT }}-latest"
          BACKEND_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:${{ steps.set-env.outputs.ENVIRONMENT }}-latest"
          sed "s|\${FRONTEND_IMAGE}|$FRONTEND_IMAGE|g; s|\${BACKEND_IMAGE}|$BACKEND_IMAGE|g; s|\${ENVIRONMENT}|${{ steps.set-env.outputs.ENVIRONMENT }}|g" \
            docker-compose.template.yml > docker-compose.yml

      - name: Copy files to EC2
        run: |
          # Create deployment directories
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"${{ steps.set-env.outputs.EC2_INSTANCE_ID }}\"]}]" \
            --parameters "{\"commands\":[
              \"mkdir -p ${{ env.APP_DIR }}\",
              \"mkdir -p ${{ env.APP_DIR }}/temp\",
              \"chmod 755 ${{ env.APP_DIR }}\",
              \"chmod 755 ${{ env.APP_DIR }}/temp\"
            ]}" \
            --output text

          # Wait for directory creation
          sleep 5

          # Encode and transfer docker-compose file
          DOCKER_COMPOSE_B64=$(base64 -w 0 docker-compose.yml)

          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"${{ steps.set-env.outputs.EC2_INSTANCE_ID }}\"]}]" \
            --parameters "{\"commands\":[
              \"echo '${DOCKER_COMPOSE_B64}' | base64 -d > ${{ env.APP_DIR }}/temp/docker-compose.yml\",
              \"if [ -f ${{ env.APP_DIR }}/temp/docker-compose.yml ]; then echo 'File transfer successful'; else echo 'File transfer failed' >&2; exit 1; fi\"
            ]}" \
            --output text

          # Verify file permissions and content
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"${{ steps.set-env.outputs.EC2_INSTANCE_ID }}\"]}]" \
            --parameters "{\"commands\":[
              \"ls -la ${{ env.APP_DIR }}/temp/docker-compose.yml\",
              \"head -n 1 ${{ env.APP_DIR }}/temp/docker-compose.yml\"
            ]}" \
            --output text

      - name: Deploy using SSM
        run: |
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"${{ steps.set-env.outputs.EC2_INSTANCE_ID }}\"]}]" \
            --parameters "{\"commands\":[
              \"cd ${{ env.APP_DIR }}\",
              \"cat > .env << 'EOL'\\nPOSTGRES_USER=postgres\\nPOSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}\\nPOSTGRES_DB=postgres-${{ steps.set-env.outputs.ENVIRONMENT }}\\nPROJECT_NAME=${{ secrets.PROJECT_NAME }}\\nOPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}\\nOPENAI_MODEL=${{ secrets.OPENAI_MODEL }}\\nHF_EMBEDDING_MODEL=${{ secrets.HF_EMBEDDING_MODEL }}\\nHF_EMBEDDER_AUTH_TOKEN=${{ secrets.HF_EMBEDDER_AUTH_TOKEN }}\\nEOL\",
              \"sudo chown -R ec2-user:docker .\",
              \"sudo chmod 640 .env\",
              \"sudo -E bash -c 'aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}'\",
              \"mv temp/docker-compose.yml docker-compose.yml\",
              \"rmdir temp\",
              \"sudo docker compose down || true\",
              \"sudo docker system prune -f\",
              \"sudo docker compose pull || { echo 'Docker pull failed'; cat ~/.docker/config.json; aws sts get-caller-identity; exit 1; }\",
              \"sudo docker compose up -d\",
              \"sleep 10\",
              \"if ! sudo docker compose ps --format json | grep -q 'running'; then echo 'Containers failed to start properly' >&2; sudo docker compose logs; exit 1; fi\",
              \"echo 'Deployment completed successfully'\"
            ]}" \
            --comment "Deployment from GitHub Actions" \
            --timeout-seconds 600

      - name: Verify Deployment
        run: |
          # Wait for services to stabilize
          sleep 30

          # Comprehensive deployment verification
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"${{ steps.set-env.outputs.EC2_INSTANCE_ID }}\"]}]" \
            --parameters "{\"commands\":[
              \"cd ${{ env.APP_DIR }}\",
              \"echo 'Checking container status...'\",
              \"sudo docker compose ps\",
              \"echo 'Checking container logs...'\",
              \"sudo docker compose logs --tail=50\",
              \"echo 'Checking ECR authentication...'\",
              \"aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_FRONTEND }} ${{ env.ECR_REPOSITORY_BACKEND }} || echo 'ECR repository access failed'\",
              \"echo 'Checking container health...'\",
              \"sudo docker compose ps --format json | grep -q 'running' || { echo 'No containers running' >&2; exit 1; }\",
              \"echo 'All checks passed'\"
            ]}" \
            --output text

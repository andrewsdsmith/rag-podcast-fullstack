name: Deploy to AWS EC2

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        default: "development"
env:
  AWS_REGION: eu-west-2
  ECR_REPOSITORY_FRONTEND: rag-podcast-fullstack/frontend
  ECR_REPOSITORY_BACKEND: rag-podcast-fullstack/backend

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        id: set-env
        run: |
          echo "ENVIRONMENT=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "EC2_INSTANCE_ID=${{ secrets.DEV_EC2_INSTANCE_ID }}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${TAG}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Prepare Docker Compose File
        run: |
          FRONTEND_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:${{ steps.set-env.outputs.ENVIRONMENT }}-latest"
          BACKEND_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:${{ steps.set-env.outputs.ENVIRONMENT }}-latest"
          sed "s|\${FRONTEND_IMAGE}|$FRONTEND_IMAGE|g; s|\${BACKEND_IMAGE}|$BACKEND_IMAGE|g; s|\${ENVIRONMENT}|${{ steps.set-env.outputs.ENVIRONMENT }}|g; s|\${CERTBOT_EMAIL}|${{secrets.CERTBOT_EMAIL}}|g; s|\${DOMAIN_NAME}|${{secrets.DOMAIN_NAME}}|g" \
            docker-compose.template.yml > docker-compose.yml

      - name: Prepare Nginx Configuration
        run: |
          sed "s|\${DOMAIN_NAME}|${{ secrets.DOMAIN_NAME }}|g" \
            nginx.deployment.conf > nginx.conf

      - name: Deploy to EC2
        run: |
          # First command: Setup and verify deployment directory
          SETUP_RESULT=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"${{ steps.set-env.outputs.EC2_INSTANCE_ID }}\"]}]" \
            --parameters '{
              "commands": [
                "set -e",
                "echo \"Starting deployment setup at $(date)\"",
                "if [ ! -d \"${{ secrets.APP_DIR }}\" ]; then mkdir -p \"${{ secrets.APP_DIR }}\"; fi",
                "cd \"${{ secrets.APP_DIR }}\"",
                "ls -la",
                "echo \"Cleaning directory...\"",
                "rm -rf *",
                "ls -la",
                "echo \"Creating new .env file...\"",
                "cat << EOF > .env
                POSTGRES_USER=${{ secrets.POSTGRES_USER }}
                POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
                POSTGRES_DB=postgres-${{ steps.set-env.outputs.ENVIRONMENT }}
                PROJECT_NAME=${{ secrets.PROJECT_NAME }}
                OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
                OPENAI_MODEL=${{ secrets.OPENAI_MODEL }}
                HF_EMBEDDING_MODEL=${{ secrets.HF_EMBEDDING_MODEL }}
                HF_EMBEDDER_AUTH_TOKEN=${{ secrets.HF_EMBEDDER_AUTH_TOKEN }}
                EOF",
                "sudo chown -R ubuntu:docker .",
                "sudo chmod 640 .env",
                "cat .env | grep -v -E \"(PASSWORD|KEY|TOKEN)\"",
                "echo \"Setup completed successfully\""
              ],
              "workingDirectory": ["/"],
              "executionTimeout": ["3600"]
            }' \
            --output json)

          # Store the command ID
          COMMAND_ID=$(echo $SETUP_RESULT | jq -r '.Command.CommandId')

          # Wait for command completion and check status
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "${{ steps.set-env.outputs.EC2_INSTANCE_ID }}"

          # Get command result
          RESULT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.set-env.outputs.EC2_INSTANCE_ID }}" \
            --output json)

          # Check status and output
          STATUS=$(echo $RESULT | jq -r '.Status')
          if [ "$STATUS" != "Success" ]; then
            echo "Setup failed with status: $STATUS"
            echo "Command output:"
            echo $RESULT | jq -r '.StandardOutputContent'
            echo "Error output:"
            echo $RESULT | jq -r '.StandardErrorContent'
            exit 1
          fi

          # Copy files to S3
          aws s3 cp docker-compose.yml s3://${{ secrets.DEPLOYMENT_BUCKET }}/docker-compose.yml
          aws s3 cp nginx.conf s3://${{ secrets.DEPLOYMENT_BUCKET }}/nginx.conf
          aws s3 cp options-ssl-nginx.conf s3://${{ secrets.DEPLOYMENT_BUCKET }}/options-ssl-nginx.conf
          aws s3 cp deploy.sh s3://${{ secrets.DEPLOYMENT_BUCKET }}/deploy.sh

          # Second command: Download and setup Docker
          DOCKER_SETUP_RESULT=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "[{\"Key\":\"InstanceIds\",\"Values\":[\"${{ steps.set-env.outputs.EC2_INSTANCE_ID }}\"]}]" \
            --parameters '{
              "commands": [
                "set -e",
                "echo \"Starting Docker setup at $(date)\"",
                "cd \"${{ secrets.APP_DIR }}\"",
                "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/docker-compose.yml .",
                "mkdir -p nginx-conf",
                "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/nginx.conf nginx-conf/nginx.conf",
                "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/options-ssl-nginx.conf nginx-conf/options-ssl-nginx.conf",
                "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/deploy.sh .",
                "chmod +x deploy.sh",
                "echo \"Logging into ECR...\"",
                "aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}",
                "echo \"Pulling Docker images...\"",
                "docker compose pull",
                "echo \"Docker setup completed successfully\""
              ],
              "workingDirectory": ["/"],
              "executionTimeout": ["3600"]
            }' \
            --output json)

          # Wait and verify second command
          COMMAND_ID=$(echo $DOCKER_SETUP_RESULT | jq -r '.Command.CommandId')
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "${{ steps.set-env.outputs.EC2_INSTANCE_ID }}"

          RESULT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.set-env.outputs.EC2_INSTANCE_ID }}" \
            --output json)

          STATUS=$(echo $RESULT | jq -r '.Status')
          if [ "$STATUS" != "Success" ]; then
            echo "Docker setup failed with status: $STATUS"
            echo "Command output:"
            echo $RESULT | jq -r '.StandardOutputContent'
            echo "Error output:"
            echo $RESULT | jq -r '.StandardErrorContent'
            exit 1
          fi
